---
layout: post
title:  "Что значит JavaScript в 2016"
date:   2016-10-04 19:00:00 +0300
categories: tutorials
tags: javascript
related_courses: js_advanced
permalink: web-2016
level: 1
---

# Что значит JavaScript в 2016

#### Какого это, заниматься веб разработкой в 2016 году? 

Замечательная [статья](https://hackernoon.com/how-it-feels-to-learn-javascript-in-2016-d3a717dd577f#.5fadyw8j3) Jose Aguinaga о том, как выглядит JavaScript разработчик в 2016 настолько хороша, что мы решили перевести ее и оформить в виде комикса.

![stage1](img/post-images/web-2016/01.png)
![stage2](img/post-images/web-2016/02.png)
![stage3](img/post-images/web-2016/03.png)
![stage4](img/post-images/web-2016/04.png)
![stage5](img/post-images/web-2016/05.png)
![stage6](img/post-images/web-2016/06.png)
![stage7](img/post-images/web-2016/07.png)
![stage8](img/post-images/web-2016/08.png)
![stage9](img/post-images/web-2016/09.png)
![stage10](img/post-images/web-2016/10.png)
![stage11](img/post-images/web-2016/11.png)
![stage12](img/post-images/web-2016/12.png)
![stage13](img/post-images/web-2016/13.png)
![stage14](img/post-images/web-2016/14.png)
![stage15](img/post-images/web-2016/15.png)
![stage16](img/post-images/web-2016/16.png)
![stage17](img/post-images/web-2016/17.png)
![stage18](img/post-images/web-2016/18.png)
![stage19](img/post-images/web-2016/19.png)
![stage20](img/post-images/web-2016/20.png)
![stage21](img/post-images/web-2016/21.png)
![stage22](img/post-images/web-2016/22.png)
![stage23](img/post-images/web-2016/23.png)
![stage24](img/post-images/web-2016/24.png)
![stage25](img/post-images/web-2016/25.png)
![stage26](img/post-images/web-2016/26.png)
![stage27](img/post-images/web-2016/27.png)
![stage28](img/post-images/web-2016/28.png)
![stage29](img/post-images/web-2016/29.png)



Привет чувак, мне тут новый веб проект привалил, но я так давно не кодил, я слышал там все поменялось. Ты вроде, бы как в теме веб программирования?

Вообще-то это теперь называется front-end разработка. Ну да, я тот кто тебе нужен. Я занимаюсь этим так как надо в 2016, визуализация, аудио плееры, летающие дроны, которые играют в футбол, и все такое. Я только вернулся с JsConf и ReactConf. Так что я знаю все про самые последние технологии, для того чтобы создавать веб приложения.

Круто. Мне надо сделать страничку которая показывает последние активности пользователей. Так что мне просто надо показывать данные с сервера, типа REST, сделать какие-нибудь таблички которые можно сортировать и фильтровать, и обновлять как только обновляются данные на сервере. Я думал может быть нужен jQuery для того чтобы посылать запросы на сервер что-то такое.

Не гони, никто не использует больше  jQuery тебе нужно выучить React, это же 2016.

А, ну ок, а что такое react?


Это супер крутая библиотека которую делали чуваки из Facebook. Реальная производительность и полный контроль за изменениями вьюшек в твоем приложении.


Это звучит интересно, то есть я могу использовать React для того чтобы показывать данные с сервера?


Да но сначала тебе нужно будет подключить React и React DOM.



Подожди, а почему две библиотеки?


JSX? Что такое JSX?

JSX это типа как JavaScript который выглядит как XML. Это типа как другой вариант описывать DOM, считай как улучшенный HTML.

А что не так с HTML?

Но это же 2016 никто теперь не пишет HTML.

 
Ага, понятно, короче если я добавлю 2 эти библиотеки, смогу использовать react?


Ну не совсем. Тебе еще нужно добавить Babel и тогда ты действительно сможешь использовать React.


Еще одна библиотека? Что такое Babel?

А ну Babel это транспайлер который помогает преобразовывать особенные версии JavaScript в обычную версию, если ты пишешь на любой другой версии. И если ты этого не сделаешь, тебе придется использовать ES5, но сейчас же 2016 и уже надо писать как все крутые парни на ES 2016

ES5? ES2016+? Я потерялся Что значит ES5 и ES2016+?

Ну ты древний. ES5 - то ECMAScript 5. Та редакция к который все привыкли и она работает в большинстве браузеров.

ECMAScript?

Ну да, ты знаешь это типа стандарт JavaScript который так стал называться в 1999  после того как назывался LifeScript и работал только в Netscape Navigator.  Тогда конечно была неразбериха, но сейчас, наконец-то все понятно и у нас есть как бы 7 редакций этой спецификации.

Серьезно 7 редакций? Так а что ж такое ES5 и ES2016+.

Соответственно 5 и 7 редакции.

Подожди, а что случилось 6?

ты имеешь ввиду ES6? Ну да, тр есть, каждая редакция это надстройка над предыдущей так что, если ты используешь ES2016+, ты можешь пользоваться всеми возможностями предыдущих версий.

Так, а почему надо использовать ES2016+, а не ES6?

На самом деле ты мог бы использовать ES6, но для того чтобы использовать все эти крутые фичи типа async и await, тебе необходимо использовать ES2016+. Иначе ты застрял ES6 генераторами и всеми этими параллельными процессами чтобы блокировать асинхронные вызовы.

Я понятия не имею о чем ты только что говорил, все эти названия такие запутанные. Слушай мне всего лишь надо загрузить данные с сервера, когда-то я просто использовал jQuery с  CDN чтобы просто достать данные с сервера с AJAX. Почему нельзя сделать также?

Чувак, ну это ж 2016, никто не использует jQuery больше, это ж макаронный код, все же это знают.

Ясно. То есть теперь надо загружать 3 библиотеки для того чтобы показать HTML табличку?

Ну, ты подключаешь 3 библиотеки, но тебе необходимо использовать менеджер модулей для того чтобы загрузить их в один файл.

Понятно, а что такое модуль менеджер?

Это зависит от того какая у тебя среда, но чаще всего, это значит что тебе нужно что то что поддерживает AMD или CommonJS модули.

Понятно. А AMD и CommonJS это…?

Определения. Это такие способы описать как разные JavaScript библиотеки и классы должны взаимодействовать. Ну ты знаешь exports и requires. Ты можешь писать разные файлы, использовать AMD или CommonJS API, а потом объединить их чем-то типа Browserify.

Так, это имеет смысл... мне так кажется, наверное. И что же такое browserify?

Это такой инструмент который позволяет объединить CommonJS зависимости, чтобы можно было запустить их в браузере. Он был создан потому что большинство этих зависимостей публикуется в npm registry?
npm registry?

Это такой большой публичный репозиторий,  куда все складывают свои модули.

Как CDN?

Ну, не совсем. Это вроде как централизованная база данных куда все могут отправлять библиотеки, так чтобы ты мог локально их затребовать для разработки.

Типа как Bower!

Ну да, но это же 2016, больше никто не использует Bower.

Ну ясно... Так теперь надо загружать с npm?

Да. Ну например, если ты хочешь использовать react, ты загружаешь React модуль и импортируешь его, и так можно сделать с любой популярной JavaScript библиотекой.

А! Как Angular!

Ну Angular это так по-2015. Ну да, Angular тоже там будем, точно также VueJS или RxJS и другие крутые библиотеки 2016, хочешь узнать о них побольше?

Давай все таки про React, я и так уже слишком много всего узнал нового. Итак, для того чтобы использовать react, я подтягиваю его из этого npm а потом использую эту фигню Browserify?

Да

Это выглядит слишком сложно, как для того, чтобы взять несколько зависимостей и связать их вместе.

Это так и есть, поэтому ты используешь task manager Grunt или Gulp, или Broccoli для того чтобы автоматически запустить browserify. Ты даже можешь использовать Mimosa.

Grunt? Gulp? Broccoli? Mimosa? О чем мы сейчас говорим?

Таск-менеджеры. Но на самом деле они уже не клевые. Это типа тоже 2015,  когда мы использовали Makefiles, но теперь мы используем Webpack.

Makefiles? Я думал это больше всего использовалась в C или C++ проектах.

Ну да, но очевидно в веб мы любим все усложнять, а потом возвращаться опять к основам, мы делаем это каждый год, так что подожди и скоро мы будем  использовать ассемблер в веб через год или два.

Ого. Погоди я еще не разобрался с тем что ты говорил про Webpack?

Это еще один менеджер модулей для браузера, и в тоже время task runner. Типа как улучшенный browserify.

Ага, и чем лучше?

Ну может не лучше, просто в нем больше возможностей по-разному объединить зависимости. Webpack позволяет тебе использовать другие модуль менеджеры. Ты можешь объединить не только  CommonJS но и, например native ES6 модули.

Вот это уже совсем непонятно все эти CommonJS/ES6.

Всем не понятно, но можно не переживать, ведь есть SystemJS.

О Боге, еще одно слово-js. И что такое SystemJS?

Ну, в отличии от Browserify и Webpack 1.x, SystemJS это динамический загрузчик модулей, который позволяет объединить несколько модулей в несколько файлов, вместо того чтобы загружать все в один большой файл.

Погоди, но я уже подумал что мы хотели загрузить все наши библиотеки в один большой файл и под подгружать его.

Да, но скоро будет HTTP/2  и теперь множественные HTTP  запросы на самом деле лучше.

Подожди. Так получается, что мы не можем просто добавить 3 библиотеки для react?

Не совсем. То есть, ты конечно можешь добавить их  как внешние скрипты из CDN,  но тебе все равно понадобится подключить Babel.

Так.  И это плохо?

Да ты будешь подключать весь babel-core,  и это будет неэффективно для  production, на  production тебе нужно выполнять серию предварительных задач для подготовки проекта, от которых весь твой процесс вызова Сатаны выглядит как рецепт приготовления яиц. Тебе еще надо ассеты minify и uglify, заинлайнить css и в тоже время…

Понятно, понятно. Так что если ты не можешь взять библиотеки на прямую из CDN,  еще раз как надо делать?

Я бы транспайлил их из Typescript используя комбинацию из Webpack + SystemJS + Babel.

Typescript? Я думал мы собирались писать JavaScript!

Typescript это и есть JavaScript,  правильнее сказать надстройка над JavaScript,  а точнее сказать над JavaScript версии ES6, ну ты понял, та самая 6 версия о которой мы говорили.

Я думал ES2016+  итак надстройка над ES6!  Почему мы теперь называем это Typescript?


А ну потому что он позволяет использовать JavaScript как типизированный язык  и уменьшает количество run-time ошибок, это же 2016, теперь надо добавлять типизацию в JavaScript  код.

Ага. Ясное дело этим занимается Typescript.

Ну еще есть Flow, но он просто проверяет типы данных, тогда как Typescript  - это надстройка над JavaScript, которую еще надо и компилировать.

Ага... И что такое Flow?

Это проверка статических типов, сделанный какими-то чуваками из Facebook. Они написали его на OCaml, потому что функциональное программирование, это круто.

OCaml? Функциональное программирование?

Это  что использует все хипстеры сейчас, это же 2016. Функциональное программирование? Функции высшего порядка? Каррирование? Чистая функция?

Понятия не имею о чем ты говоришь.

Сначала никто не понимает. Все что тебе нужно знать - что функциональное программирование это лучше чем ООП  и его необходимо использовать в 2016.

Погоди. Я учил ООП в институте. Я думал это хорошо?

Также как и Java до того как его купил Oracle. Я имею в виду ООП был хороший  в те дни и его еще можно использовать сегодня, но сейчас все понимают что изменять состояние это все равно как бить детей. Так что теперь все приходят к неизменяемым объектам и функциональному программированию, чуваки из Haskell давно об этом говорили и давай я не буду начинать про Elm. Но к счастью, в Web у нас теперь есть библиотеки типа Ramda с которыми можно использовать функциональное программирование на чистом JavaScript.

Ты что просто перечисляешь названия что еще такое Ramnda?

Нет. Ramda  как Lambda.  Ну знаешь, это  библиотека Давида Чемберса.

Какого Девида?

Давида Чемберса. Крутой чувак, очень важный, один из авторов Ramda, тебе еще надо знать про Эрика Мейера, если ты собираешься изучать функциональное программирование.

А Эрик Мейер кто?

Тоже Чувак по функциональному программированию, четкий пацан. У него есть куча презентации, где он гнобит Agile  в странной рубашке.

Ну хорошо давай тут остановимся, это все чудесно, но мне кажется все это слишком сложно и не нужно знать всех этих людей для того чтобы создавать таблички с динамическими данными. Давай вернемся к react, как мне взять данные из сервера с помощью  react?

Но на самом деле ты не берёшь данные с помощью react. Ты просто показываешь данные с помощью  react.

Да иди ты, и с помощью чего брать данные?

Ну, для этого есть Fetch.

Чего? Ты используешь Fetch для того, чтобы фетчить данные. Кто бы ни придумывал эти названия, нуждается в словаре.

Правда? Fetch это название для нативной имплементации для XMLHttpRequest на сервер.

Ах, ну теперь AJAX.

AJAX это просто использование XMLHttpRequest, но Fetch позволяет тебе использовать AJAX на основе промисов, чтобы избежать ада колбеков.

Ад колбеков?

Ага. Каждый раз когда ты отправляешь асинхронный запрос на сервер, тебе необходимо дождаться ответа, и ты начинаешь добавлять функцию за функцией, это называется пирамидой колбеков из ада.

А, ок, и эти самые промисы решают проблему?

На самом деле да. Когда ты манипулируешь колбеками через промисы, тебе проще понять код и протестировать его, а еще делать одновременные запросы.

И со всем этим справится Fetch?

Да, но только если твой пользователь использует evergreen браузер, иначе тебе надо добавить polyfill для того чтобы его использовать или бери Request, Bluebird или Axios.

Как много библиотек мне нужно, для того чтобы сделать простые серверные запросы вообще как много их?

Это же JavaScript. Их должно быть 1000 библиотек которые делают одно и тоже, наши библиотеки огромны, иногда мы даже добавляем в них фото Гая Фиери.

Ты сказал Гай Фиери? Давай покончим с этим. Расскажи еще что такое эти  библиотеки Bluebird, Request, Axios

Это библиотеки, которые делают XMLHttpRequest и возвращают промисы.

А разве jQuery AJAX не делает того же самого?

Мы больше не используем слово на букву “J” в 2016. Просто бери Fetch, и делай полифил, если его нет в браузере, или возьми вместо него Bluebird, Request или Axios. Потом разруливай промисы с await и бум! у тебя есть правильный control flow.

Ты уже третий раз говоришь про await но я так и не понял что это такое.

Await позволяет тебе заблокировать асинхронный вызов, что позволяет тебе лучше контролировать время когда данные будут загружены с сервера и в целом позволит написать более читаемый код. Это круто. Все что тебе надо - это убедиться, что ты используешь stage-3 preset в Babel,  или syntax-async-functions и transform-async-to-generator плагин.

Это дурдом

Нет, дурдом это тот факт, что тебе надо компилировать Typescript код а потом транспайлить его с Babel для того чтобы получить await.

Чеее? Он не включен в Typescript?

В следующей версии, но пока в версии 1.7 он воспринимают только ES6, так что, если хочешь чтобы был await в браузере сначала надо компилировать Typescript  код в ES6 а потом Babel, чтобы все это перевести в ES5.

Я не даже не знаю что сказать.

Слушай, это просто. Все пишешь на Typescript.  Все модули которые, используют Fetch  компилируешь в ES6, транспайлишь с Babel на stage-3 preset и загружаешь их с SystemJS. А если у тебя нет Fetch полифиль его или бери Bluebird, Request или Axios и разбирайся со своими промисами с await.

У нас совершенно разные понятия о том что такое просто. Итак со всеми этими танцами с бубном, я наконец-то смогу брать данные с сервера и показывать их с помощью react?

А твое приложение собирается изменять состояние?

Эмм, не думаю, все что мне надо это просто показывать данные.

Ох, ну слава Богу. Иначе пришлось бы тебе объяснить про Flux и все его реализации типа Flummox, Alt, Fluxible. Хотя честно говоря, все же лучше использовать Redux.

Давай просто пропустим эти названия. Еще раз повторяю, мне надо просто показывать данные.

А, ну если тебе надо просто показывать данные, ты можешь и не использовать  react можешь просто взять какой-нибудь шаблонизатор.

Ты что прикалываешься? Думаешь это смешно? И это так, ты думаешь, надо общаться со своими друзьями?

 Я просто пытаюсь объяснить твои возможности.

Все тормози. Просто остановись.

Кстати даже если просто шаблонизатор  все равно  я бы использовал комбинацию Typescript + SystemJS + Babel  на твоем месте.

Мне просто надо показывать данные на страничке, а не выполнять смертельный трюк. Просто скажи какой шаблонизатор использовать и я начну с этого.

Так их много ты хоть один знаешь?

Не могу вспомнить название это было давно.

-jTemplates? jQote? PURE?
Ниочем не говорит. А есть еще что-то?

-Transparency? JSRender? MarkupJS? KnockoutJS? У этого есть two-way binding. Еще?

-PlatesJS? jQuery-tmpl? Handlebars? Некоторые до сих пор его используют.

Может быть. А есть что-то похожее на последний?
-Mustache, underscore? Мне кажется теперь никто даже lodash не пользуется это же все из 2014.

Этот может быть более новым
-Jade? DustJS? DotJS? EJS? Nunjucks? ECT? чувак, никто теперь не любит синтаксис coffeescript  может Jade?

 нет Ты уже говорил Jade

 я имею в виду Pug  то есть Jade,  то есть Jade  теперь Pug.

 Нет, не могу вспомнить какой бы ты использовал?

 скорее всего тот который теперь есть в ES6

Дай угадаю а Для этого мне надо использовать ES6, который зависит от того какой я использую браузер и нужен Babel, который Если я хочу подключить без добавления всей библиотеки я должен загружаться как модуль из npm, который требует Browserify, или Wepback или даже, скорее всего та штука которая называется SystemJS, которая, если только это не Webpack,  в идеале должно управляться Task Runner-ом. Но поскольку мне нужно использовать функциональное программирование и типизированный язык для начала мне нужно писать на Typescript или добавить эту Flow штуковину. А потом отправить это все в Babel если я захочу взять await, Fetch, промисы и вся эта магия.

Только не забудь полифилить Fetch если он не поддерживается Safari все еще не может с ним справиться

Знаешь что я думаю? Мы закончили! На самом деле я думаю я закончил! Я закончил работать в Веб и я покончил с джаваскпитом!!1

 это ничего Через пару лет Мы все будем писать на Elm или WebAssembly.

 я просто вернусь на бекенд, я просто не могу справиться с таким количеством изменение версий, компиляторов и транспайлеров  сообщество JavaScript просто сошло с ума, если думает что кто-либо может с этим справиться

 я тебя услышал, тогда может попробуешь Python сообщество?

 Это почему

 ты слышал про 3 Python 
